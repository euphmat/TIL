# 所有権

+ Rustでは、変数束縛を行うと、その変数が関連付けられた値の所有権を持つ。と表現されます。
+ 以下の場合、スコープ内では`tom`という変数が`5`の値を所有し、束縛していることになります。
+ その後、スコープを抜けるときに`tom`が束縛していた`5`の値は解放され、破棄されます。
  + このことを、Rustでは`drop`と呼びます。

```rust
fn main() {
        let tom = 5;
}
```

## 所有権は移る 

+ 以下の例では、はじめに変数`a`がString型の文字列`"Hello"`を束縛しています。
+ 次に、変数`b`が変数`a`を代入しています。
+ C言語やJavaなどの別の言語では、変数`a`の内容が`b`にコピーされますが、Rustでは、違う動きをします。
+ 代入が発生したことにより、文字列`"Hello"`の所有権が変数`a`から変数`b`に移動しました。
+ つまり、変数`a`は所有権を失い、束縛するものがなくなったため、無効となります。


```rust
fn main() {
        let a = String::from("Hello");
        let b = a;
        
        println!("a = {}", a); // 既にaは無効なため、コンパイルエラー
        println!("b = {}", b);
}
```

## 所有権は移動しない場合がある 

+ 気を付けたいこととして、代入が発生したとき、必ず所有権の移動が発生するわけではありません。
+ 以下の、整数のようなコンパイル時に既知のサイズを持つ型は、動作が高速なため、所有権の移動は発生せず、データがコピーされます。


```rust
fn main() {
        let a = 5;
        let b = a;

        println!("a = {}", a);
        println!("b = {}", b);

}
```

## 所有権が移動するデータと移動しないデータの違い

+ 所有権が移動するデータは、`ヒープ`領域にメモリが確保される。
  + String型
+ 所有権が移動しないデータは、`スタック`領域にメモリが確保される。
  + あらゆる整数型や論理値型、文字型(char)や、これらの型のみで構成されたタプル。


