# 所有権とは？

## 所有権の目的

+ 安全なメモリ管理を実現するのが目的

## 所有権のルール

+ Rustの各値は`所有者`と呼ばれる変数と対応している。
+ いかなる時も所有者は一つである。
+ 所有者がスコープから外れたら、値は破棄される。

## 所有権

+ 各値は一つの変数に所有され、その変数からしか読み込み、書き込みを行わない
+ 変数が宣言されたブロックでの処理が終了すると、変数が所有していた値は破棄される
  + これにより、メモリの確保、解放のタイミングがコンパイル時に決定されるため、GCが不要。
+ 以上のルールから、「値が複数の変数から同時更新されて壊れること」や、「値を解放し忘れてメモリリーク」することを防ぐことができる。

```rust
fn main() {
        let a = 10;      // a は 10を所有する
        let b = "hello"; // b は "hello"を所有する
#println!(a = {}, a);
#println!(b = {}, b);
} // スコープが終了。aとbは無効になり、所有していた値は破棄される。

```

## 所有権の移動 : スタック

+ 所有権の移動とは「変数A」から「変数B」へ値を代入するとき、「変数A」の所有権を「変数B」に移動させ、「変数A」を無効化すること。
+ 整数など、既知の固定サイズの値はスタックにつまれます。  
+ スタック上のデータはすべて既知のサイズでなければなりません。  
+ スタックは高速なので、変数に対して代入を行っても、所有権の移動は発生せず、単純に値がコピーされます。  
+ スタックに積まれるものは、`copy`トレイトに適合しているもの。

```rust
fn main() {
        let a = 5; // 5 の所有権:a
        let b = a; // a のデータはスタックにつまれているため、bにコピーされる
#println!("a = {}", a);
#println!("b = {}", b);
}
```

## 所有権の移動 : ヒープ

+ コンパイル時にサイズが不明であったり、サイズが可変のデータについては、ヒープに格納されます。  
+ OSはヒープ上に十分な大きさの空の領域を見つけ、使用中にし、ポインタを返します。  
+ ヒープへのアクセスは、ポインタを追って目的の場所へ到達しなければならないため、スタックよりも低速です。  
+ そのため、ヒープに格納されたデータを持つ所有者を変更するとき、ヒープに格納されたデータではなく、ポインタのみをコピーします。  
+ また、コピーした後は、二重開放エラーを防ぐため、もともとデータを所有していた変数は無効化されます。  

```rust
fn main() {
        let a = String::from("hello"); // Stringの所有権: a
        let b = a;                     // Stringの所有権: b
#println!("b = {}", b);
}
```

## 関数を呼ぶことで所有権は移動する

```rust
fn main() {
        let a = String::from("hello");    // Stringの所有権:a
        let result = print_string(a);     // Stringの所有権:print_string の s
        println!("result = {}", result);
}

fn print_string(s: String) -> String{
        return s                          // Stringの所有権 main の result
}
```
