# What is OwnerShip

+ 所有権とは、Rustの中心的な機能である

## 所有権規則

+ Rustの各値は、`所有者`と呼ばれる変数と対応している
+ いかなる時も`所有者`はひとつである
+ `所有者`がスコープから外れたら、値は破棄される

## 変数スコープ

+ 変数スコープとは、要素が有効になるプログラム内の範囲のこと
+ 例としては以下のような形

```rust
#fn main() {
{                              // 変数sは有効になっていない
        let s = "hello";       // 変数sはここから有効になる
        println!("s = {}",s);  // 変数sで作業
}                              // 変数sは無効
#}
```

## String型で理解する所有権

+ `String::from`はString型のfrom関数を使用して、文字リテラルから`String`型を生成している
+ `String`型はヒープにメモリを確保するため、コンパイル時にサイズが不明なテキストも保持することができる

```rust
let mut s = String::from("String");
let mut c = "Char";

s.push_str(" World"); // リテラルをsに付け加える
c.push_str(" World"); // リテラルには付け加えられない、コンパイルエラー

println!("s = {}", s);
println!("c = {}", c);
```

## メモリと確保

+ 文字列リテラルの場合、中身はコンパイル時に判明している
  + 最終的にバイナルファイルにいハードコードされる
  + 文字列リテラルは高速で効率的になる

+ `String`型では、伸縮可能なテキストをサポートするために、コンパイル時には不明な量のヒープを確保します。
  + メモリは、実行時にOSに要求される
  + `String`型を使用し終わったら、OSniメモリを返還する方法が必要

> メモリは実行時にOSに要求される

この部分は`String::from`関数を呼ぶことで解決しています

> `String`型を使用し終わったら、OSniメモリを返還する方法が必要

この部分は少し異なります。  
+ `GC`付きの言語では、`GC`がこれ以上使用されないメモリを検知して片づけるため、プログラマがそのことを考慮する必要はない  
+ `GC`がない言語では、プログラマが明示的に返還するコードを呼び出す必要があります

+ Rustは上記２つとは異なった道を歩んでいます
  + メモリを所有している変数がスコープを抜けたら、メモリは自動的に返還されます
  + 変数がスコープを抜けるとき、Rustは特別な関数を呼びます
  + その関数は`drop`とよばれ、Rustは`}`で自動的に`drop`関数を呼び出します
  + これらはRustコードの書き方に甚大な影響をもたらします

## 変数とデータの相互作用

+ 以下のコードは値`5`を変数`x`に束縛する。
+ それから変数`x`の値をコピーし、`y`に束縛する
+ これらの値は既知の固定サイズのため、スタックに積まれる

```rust
let x = 5;
let y = x;

println!("x = {}", x);
println!("y = {}", y);
```

+ 下記コードは、上記の`String`バージョンです
+ `s1`を`s2`に代入すると、`String型`のデータがコピーされます
+ つまり、String型はヒープに確保されるため、`pointer`,`length`,`capacity`のデータをコピーすることになります。
+ "hello"というリテラルはコピーされません

```rust
let s1 = String::from("hello");
let s2 = s1;
```

## 二重開放エラー

+ 変数がスコープを抜けた場合、Rustは自動的に`drop`関数を呼びだし、その変数が使っていたヒープメモリを片付けると記載しました
+ しかし、上記のようなコードの場合、`s1`と`s2`はポインタが同じ場所を指しています
+ この場合、`s1`と`s2`がスコープを抜けたら、両方とも同じヒープメモリを解放しようとします。
+ このことを、`二重開放エラー`と呼びます
+ Rustにおいては、二重開放エラーを事前に防ぐため、確保されたメモリをコピーしようとする代わりに、コンパイラはもはや‘`s1`は有効ではないと考えます
+ つまり、所有権が`s2`に移った辞典でs1ののデータは無効になり、`drop`が呼ばれたとき、`s2`だけがメモリを解放することになります

```rust
let s1 = String::from("hello"); // String型のデータ、ヒープメモリのデータの所有権:s1
let s2 = s1;                    // 所有権がs2に移る

println!("{}, world!", s1);     // s1に所有権がないため、コンパイルエラー
```
## `clone`メソッド

+ もし、本当にヒープメモリ上のデータをコピーしたい場合、`clone`メソッドを使用します
```rust
let s1 = String::from("hello"); 
let s2 = s1.clone();

println!("{}, world s1!", s1);
println!("{}, world s2!", s2);
```

## スタックの場合

+ `clone`メソッドは無いですが、うまく動作します
+ 理由として、整数のようなコンパイル時に既知のサイズを持つ型はスタックに保持され、コピー動作も高速だからです
  + これは、変数`y`を生成した後も、`x`を無効化する理由が特にないことを示します
 

```rust
let x = 5;
let y = x;

println!("x = {}", x);
println!("y = {}", y);
```
## `copy`トレイトに適合する型

+ 上記コードのように、`clone`を使わずにコピーできる型は、`copy`トレイトに適合する型です
+ 下記コード`char`型も、`copy`トレイトに適合するため、うまく動作します
+ 適合する型の特徴としては、スカラー値の集合`u32`,`bool`,`f64`,`char`など
+ 適合しない型の特徴としては、メモリの確保が必要であったり何らかの形態のリソースだったりするものは`copy`ではない

```rust
let s = "HELLO";
let d = s;

println!("s = {}",s);
println!("d = {}",d);
```

## 所有権と関数

+ 関数に値を渡すことと、値を変数に代入することは意味論的に似ている
+ 関数に変数を渡すと、代入のようにムーブ、コピーされます。
```rust
fn main() {
        let s = String::from("hello");  // sがString型とヒープメモリデータの所有権を持つ
        takes_ownership(s);             // sを引数として関数を呼ぶ、所有権が移り、sは無効となる
        let x = 5;                      // xがスタックに保持される
        makes_copy(x);                  // xをスタック方取り出して、それを引数として関数を呼ぶ
        println!("x = {}", x);          // xはムーブされていないため、使用可能
}

fn takes_ownership(some_string: String) { // some_Stringが変数sのデータを受け取り、所有権を持つ
        println!("{}", some_string);
} // dropが呼ばれ、ヒープに確保されていたメモリが解放される

fn makes_copy(some_integer: i32) {
        println!("{}",some_integer);
}
```

## 戻り値とスコープ

+ 値を返すことでも所有権は移動します

```rust
fn main() {
        let s1 = gives_ownership();        // 関数を呼び出し、戻り値をs1にムーブする
        let s2 = String::from("s2");       // s2がスコープに入る。ヒープメモリ上にデータを格納する 
        println!("s2 = {}", s2);           // 所有権はここまで
        let s3 = takes_and_gives_back(s2); // s2のデータを引数として関数を呼び出す 戻り値をs3にムーブする s2は所有権を失う 
        println!("s3 = {}", s3);
        println!("s1 = {}", s1);
} // s1:drop, s3:drop s2:所有権がないため、何も起きない

fn gives_ownership() -> String {
        let some_string = String::from("gives_ownership");
        some_string                        // 呼び出し元関数にデータの所有権をムーブし、所有権を失う
}


// s2のデータをa_stringとして受け取り、すぐに呼び出し元へ返す
fn takes_and_gives_back(a_string: String) -> String {
        a_string
}
```
